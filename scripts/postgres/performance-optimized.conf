# =====================================================
# PostgreSQL Performance Optimization Configuration
# SaaS Control Deck - Multi-Environment Setup
# =====================================================
# Optimized for 6 databases across 3 environments
# Target Server: 47.79.87.199:5432 (4-8GB RAM)
# Database Load: Dev(5-10), Stage(10-20), Prod(50-100) connections

# =====================================================
# MEMORY CONFIGURATION - Optimized for AI Workloads
# =====================================================

# Shared Memory Configuration (25% of available RAM)
shared_buffers = 1200MB              # Increased for better cache hit ratio
effective_cache_size = 3200MB        # 80% of available memory for OS cache
maintenance_work_mem = 512MB         # Increased for faster VACUUM/CREATE INDEX

# Per-connection Memory (Critical for concurrent AI tasks)
work_mem = 32MB                      # Doubled for complex AI queries
temp_buffers = 64MB                  # Increased for temporary table operations
wal_buffers = 32MB                   # Increased for heavy write workloads

# Hash Table Memory (AI data processing)
max_stack_depth = 8MB
hash_mem_multiplier = 2.0            # PostgreSQL 13+ feature

# =====================================================
# CONNECTION POOL OPTIMIZATION
# =====================================================

# Connection Limits by Environment Load
max_connections = 150                # Conservative limit for stability
superuser_reserved_connections = 5   # Emergency connections

# Connection Timeouts
authentication_timeout = 30s         # Faster timeout for security
idle_in_transaction_session_timeout = 300s  # Kill hanging transactions
tcp_keepalives_idle = 300
tcp_keepalives_interval = 30
tcp_keepalives_count = 3

# =====================================================
# QUERY PLANNER OPTIMIZATION - SSD & AI Optimized
# =====================================================

# Cost Settings for SSD Storage
random_page_cost = 1.1              # SSD-optimized (down from 4.0)
seq_page_cost = 1.0                 # Base cost for sequential reads
cpu_tuple_cost = 0.008              # Slightly reduced for modern CPUs
cpu_index_tuple_cost = 0.004        # Index scan optimization
cpu_operator_cost = 0.002           # Operator cost reduction

# AI Query Optimization
effective_io_concurrency = 8        # SSD concurrent I/O capability
maintenance_io_concurrency = 4      # Maintenance operation concurrency

# Join and Sort Optimization
enable_hashjoin = on
enable_mergejoin = on
enable_nestloop = on
enable_sort = on
enable_material = on

# =====================================================
# WAL AND CHECKPOINT OPTIMIZATION
# =====================================================

# WAL Configuration for Performance
wal_level = replica                  # Required for replication/backups
wal_compression = lz4                # PostgreSQL 14+ compression
wal_init_zero = off                  # Skip zeroing on SSD
wal_recycle = off                    # Skip recycling on SSD

# Checkpoint Configuration (Balanced for performance/durability)
checkpoint_timeout = 10min          # Reduced for more frequent checkpoints
checkpoint_completion_target = 0.8   # Spread checkpoint I/O
checkpoint_flush_after = 0           # Disable for SSD
checkpoint_warning = 30s             # Warn if checkpoints too frequent

# WAL Writer Optimization
wal_writer_delay = 100ms            # More frequent WAL writes
wal_writer_flush_after = 512kB      # Smaller flush threshold

# Synchronous Commit (Balance durability vs performance)
synchronous_commit = on             # Keep on for production safety
commit_delay = 0                    # No artificial delay
commit_siblings = 5                 # Commit siblings threshold

# =====================================================
# BACKGROUND WRITER OPTIMIZATION
# =====================================================

# Background Writer (Smooth I/O distribution)
bgwriter_delay = 100ms              # More frequent background writes
bgwriter_lru_maxpages = 200         # More pages per round
bgwriter_lru_multiplier = 4.0       # Aggressive background writing
bgwriter_flush_after = 0            # Disable for SSD

# =====================================================
# AUTOVACUUM OPTIMIZATION - AI Data Optimized
# =====================================================

# Autovacuum Configuration (Aggressive for AI workloads)
autovacuum = on
autovacuum_max_workers = 4          # Increased workers for 6 databases
autovacuum_naptime = 15s            # More frequent vacuum checks

# Vacuum Thresholds (AI data has high turnover)
autovacuum_vacuum_threshold = 25    # Lower threshold for frequent updates
autovacuum_vacuum_scale_factor = 0.1  # More aggressive vacuuming
autovacuum_vacuum_insert_threshold = 1000  # PostgreSQL 13+ feature

# Analyze Thresholds (Critical for AI query performance)
autovacuum_analyze_threshold = 25   # Lower threshold for statistics
autovacuum_analyze_scale_factor = 0.05  # Very aggressive analyze

# Vacuum Cost Settings
autovacuum_vacuum_cost_delay = 5ms  # Faster vacuum operations
autovacuum_vacuum_cost_limit = 400  # Higher cost limit
vacuum_cost_page_hit = 1
vacuum_cost_page_miss = 2
vacuum_cost_page_dirty = 20

# =====================================================
# PARALLEL PROCESSING - AI Workload Optimization
# =====================================================

# Parallel Query Configuration
max_worker_processes = 12           # Increased for AI processing
max_parallel_workers = 6            # Half of worker processes
max_parallel_workers_per_gather = 2 # Conservative per-query limit
max_parallel_maintenance_workers = 4 # Parallel maintenance operations

# Parallel Query Thresholds
parallel_tuple_cost = 0.1
parallel_setup_cost = 1000.0
min_parallel_table_scan_size = 8MB
min_parallel_index_scan_size = 512kB

# Force Parallel Planning (when beneficial)
force_parallel_mode = off           # Keep off for production

# =====================================================
# STATISTICS AND MONITORING
# =====================================================

# Statistics Collection (Enhanced monitoring)
track_activities = on
track_counts = on
track_io_timing = on
track_functions = all
track_activity_query_size = 8192    # Larger query text storage

# Statistics Targets (Better query plans)
default_statistics_target = 1000    # High for AI data patterns
constraint_exclusion = partition     # Optimize partitioned tables

# =====================================================
# LOGGING CONFIGURATION - Performance Focused
# =====================================================

# Log Configuration
logging_collector = on
log_destination = 'stderr,csvlog'
log_directory = '/var/lib/postgresql/data/logs'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_file_mode = 0640
log_rotation_age = 1d
log_rotation_size = 500MB

# Performance Logging
log_min_duration_statement = 500ms  # Log queries > 500ms
log_checkpoints = on
log_connections = off               # Disable for high-connection environments
log_disconnections = off
log_lock_waits = on
log_temp_files = 50MB              # Log large temp files

# Query Analysis
log_statement = 'ddl'              # Log schema changes only
log_duration = off
log_hostname = off                  # Reduce log size
log_line_prefix = '%t [%p] %q%u@%d: '  # Optimized log format

# =====================================================
# EXTENSIONS FOR PERFORMANCE MONITORING
# =====================================================

# Shared Preload Libraries
shared_preload_libraries = 'pg_stat_statements,auto_explain,pg_prewarm'

# pg_stat_statements (Query performance tracking)
pg_stat_statements.max = 50000      # Track more queries
pg_stat_statements.track = all      # Track all statements
pg_stat_statements.track_utility = on
pg_stat_statements.track_planning = on  # PostgreSQL 13+
pg_stat_statements.save = on

# auto_explain (Automatic query plan logging)
auto_explain.log_min_duration = 1s  # Log plans for queries > 1s
auto_explain.log_analyze = on
auto_explain.log_buffers = on
auto_explain.log_timing = on
auto_explain.log_triggers = on
auto_explain.log_verbose = off
auto_explain.log_nested_statements = on

# =====================================================
# AI AND JSON OPTIMIZATION
# =====================================================

# JSON Processing (AI responses and metadata)
gin_pending_list_limit = 8MB       # Larger GIN index work area
gin_fuzzy_search_limit = 0          # No limit on fuzzy search

# Text Search (AI content indexing)
default_text_search_config = 'pg_catalog.english'

# =====================================================
# LOCK CONFIGURATION
# =====================================================

# Lock Management (Multi-database environment)
max_locks_per_transaction = 128     # Increased for complex transactions
max_pred_locks_per_transaction = 128
deadlock_timeout = 500ms           # Faster deadlock detection

# =====================================================
# SECURITY SETTINGS
# =====================================================

# Authentication and SSL
password_encryption = scram-sha-256
ssl = on
ssl_prefer_server_ciphers = on
ssl_ciphers = 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305'

# Row Level Security
row_security = on

# =====================================================
# ENVIRONMENT-SPECIFIC OVERRIDES
# =====================================================

# Development Environment Settings
# - Lower resource usage
# - More verbose logging
# (Apply via ALTER SYSTEM SET when connecting to dev databases)

# Production Environment Settings  
# - Maximum performance
# - Minimal logging
# - Strict security
# (Apply via ALTER SYSTEM SET when connecting to prod databases)

# =====================================================
# MAINTENANCE CONFIGURATION
# =====================================================

# Maintenance Operations
maintenance_work_mem = 512MB
autovacuum_work_mem = 256MB        # Dedicated vacuum memory

# File System
fsync = on                         # Keep on for data safety
synchronous_commit = on            # Keep on for consistency
full_page_writes = on              # Keep on for crash recovery
wal_log_hints = off               # Disable unless using pg_rewind

# =====================================================
# CONNECTION AND RESOURCE LIMITS
# =====================================================

# Resource Limits
max_files_per_process = 20000      # Higher file limits
max_function_stack_depth = 8MB
max_prepared_transactions = 0      # Disable unless using 2PC

# Network Configuration
listen_addresses = '*'
port = 5432
unix_socket_directories = '/var/run/postgresql'

# Timezone
timezone = 'UTC'
log_timezone = 'UTC'

# Locale
lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8' 
lc_numeric = 'en_US.UTF-8'
lc_time = 'en_US.UTF-8'

# =====================================================
# ADDITIONAL PERFORMANCE TWEAKS
# =====================================================

# JIT Compilation (PostgreSQL 11+)
jit = on                          # Enable JIT for complex queries
jit_above_cost = 500000           # Higher threshold
jit_inline_above_cost = 2000000   # Conservative inlining
jit_optimize_above_cost = 2000000 # Conservative optimization

# Vacuum and Analyze
vacuum_freeze_min_age = 50000000
vacuum_freeze_table_age = 150000000
vacuum_multixact_freeze_min_age = 5000000
vacuum_multixact_freeze_table_age = 150000000

# Old Snapshot Threshold (prevent snapshot too old errors)
old_snapshot_threshold = 60min

# Hot Standby (if using replication)
hot_standby = on
hot_standby_feedback = on
max_standby_archive_delay = 30s
max_standby_streaming_delay = 30s

# =====================================================
# END OF CONFIGURATION
# =====================================================